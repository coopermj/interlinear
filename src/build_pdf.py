#!/usr/bin/env python3
"""Build PDF from LaTeX source using LuaLaTeX."""

import subprocess
import shutil
from pathlib import Path

OUTPUT_DIR = Path(__file__).parent.parent / "output"


def check_lualatex() -> bool:
    """Check if lualatex is available."""
    return shutil.which("lualatex") is not None


def build_pdf(tex_file: Path, clean: bool = True) -> Path:
    """Compile LaTeX file to PDF using LuaLaTeX.

    Args:
        tex_file: Path to the .tex file
        clean: If True, remove auxiliary files after compilation

    Returns:
        Path to the generated PDF file

    Raises:
        RuntimeError: If compilation fails
        FileNotFoundError: If lualatex is not installed
    """
    if not check_lualatex():
        raise FileNotFoundError(
            "lualatex not found. Please install TeX Live or MacTeX.\n"
            "  macOS: brew install --cask mactex\n"
            "  Ubuntu: sudo apt install texlive-full"
        )

    tex_file = Path(tex_file).resolve()
    if not tex_file.exists():
        raise FileNotFoundError(f"LaTeX file not found: {tex_file}")

    output_dir = tex_file.parent

    # LuaLaTeX command
    cmd = [
        "lualatex",
        "-interaction=nonstopmode",
        "-halt-on-error",
        f"-output-directory={output_dir}",
        str(tex_file)
    ]

    print(f"Compiling {tex_file.name}...")

    # First pass
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        cwd=output_dir
    )

    if result.returncode != 0:
        # Extract meaningful error from log
        log_file = tex_file.with_suffix('.log')
        error_msg = extract_latex_error(log_file) if log_file.exists() else result.stdout
        raise RuntimeError(f"LuaLaTeX compilation failed:\n{error_msg}")

    # Second pass for proper pagination/references
    print("Second pass for references...")
    result = subprocess.run(
        cmd,
        capture_output=True,
        text=True,
        cwd=output_dir
    )

    if result.returncode != 0:
        log_file = tex_file.with_suffix('.log')
        error_msg = extract_latex_error(log_file) if log_file.exists() else result.stdout
        raise RuntimeError(f"LuaLaTeX compilation failed (pass 2):\n{error_msg}")

    pdf_file = tex_file.with_suffix('.pdf')

    if not pdf_file.exists():
        raise RuntimeError(f"PDF not generated: {pdf_file}")

    # Clean up auxiliary files
    if clean:
        cleanup_aux_files(tex_file)

    print(f"Generated PDF: {pdf_file}")
    return pdf_file


def extract_latex_error(log_file: Path) -> str:
    """Extract error message from LaTeX log file."""
    try:
        with open(log_file, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()

        # Look for error lines
        lines = content.split('\n')
        error_lines = []
        in_error = False

        for line in lines:
            if line.startswith('!'):
                in_error = True
            if in_error:
                error_lines.append(line)
                if len(error_lines) > 10:
                    break

        if error_lines:
            return '\n'.join(error_lines)

        # Fallback: return last 20 lines
        return '\n'.join(lines[-20:])
    except Exception:
        return "Could not read log file"


def cleanup_aux_files(tex_file: Path) -> None:
    """Remove auxiliary files generated by LaTeX."""
    extensions = ['.aux', '.log', '.out', '.toc', '.lof', '.lot']

    for ext in extensions:
        aux_file = tex_file.with_suffix(ext)
        if aux_file.exists():
            aux_file.unlink()


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Build PDF from LaTeX")
    parser.add_argument("tex_file", help="Path to .tex file")
    parser.add_argument("--no-clean", action="store_true",
                        help="Keep auxiliary files")
    args = parser.parse_args()

    try:
        pdf_path = build_pdf(Path(args.tex_file), clean=not args.no_clean)
        print(f"Success: {pdf_path}")
    except Exception as e:
        print(f"Error: {e}")
        exit(1)
